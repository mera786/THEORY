🌐 (1) What are Microservices?
################################
Microservices is an architecture style where an application is broken down into small, independent services that communicate over a network (usually HTTP). 
Each service focuses on a single business function, is independently deployable, and can be developed, scaled, and maintained separately.


🚀 (2) Why Use Spring Boot for Microservices?
###########################################
Spring Boot provides all the necessary tools and integrations (e.g., REST APIs, Eureka, Config Server, etc.) to build robust, production-ready microservices quickly.

✅ (3) Advantages of Microservices with Spring Boot:
##############################################
1. Loose coupling between services
2. Independent deployment and scaling
3. Technology flexibility (each microservice can use different tech)
4. Easier debugging, testing, and maintenance
5. Faster time-to-market


✅ (4) DisAdvantages of Microservices :
##############################################
1. Increased Complexity : have many services → handling communication, monitoring, logging, and deployment becomes harder.
2. Difficult Debugging & Tracing : A single user request may pass through multiple microservices.Tracing failures across services requires tools like Sleuth +                                                Zipkin/Jaeger.
3. Deployment Overhead : pipeline, deployment, scaling strategy → more DevOps effort compared to monolith.
4. Network Latency & Failures : Services communicate over HTTP may fail due to network issues. You need resilience patterns (Hystrix, Resilience4j, retries, circuit                                      breakers).
5. Data Management Complexity : Each microservice usually owns its own database Maintaining consistency across distributed databases is challenging.
6. Higher Resource Usage : Multiple microservices running in containers consume more memory and CPU compared to a single monolith.
7. Team Skill Requirement : Teams need to understand Spring Boot, Spring Cloud, Docker, Kubernetes, CI/CD, monitoring, discovery, security



(5) What is key principle of microservices?
###############################################
-> Microservices break an application into small, focused services built around specific business functions.
-> Each service runs independently, with its own data, and communicates lightly with others.


(6) Explain Microservices Architecture Components?
######################################################
=> basically, there is no strict order but there is a layered logical arrangement : 

[ Client (Web / Mobile / 3rd Party) ]
    |
[ API Gateway ]
    |           |
    |           --> [ Authentication & Authorization (JWT / OAuth2 tokens) ]
    |
[ Microservices (Business Logic) ]
    |           | 
    |           --> [ Database per service ]
    |           --> [ Service-to-service Communication (RestTemplate / Feign / gRPC) ]
    |           --> [ Eureka Client (service registration) ]
    |
[ Service Discovery (Eureka Server / Consul / Zookeeper) ]  
    |
[ Security Layer ]  
    |           --> [ Token Validation (JWT / OAuth2) ]
    |           --> [ Role-based Access Control (Spring Security) ]
    |
[ Centralized Config + Monitoring ]
    |           |
    |           --> [ Config Server (Spring Cloud Config) ]
    |           --> [ Monitoring + Observability 
    |                  (Spring Boot Actuator, Micrometer, Prometheus, Grafana) ]
    |           --> [ Admin Server (Spring Boot Admin for service health UI) ]
    |
[ Deployment Platform (Docker / Kubernetes / Cloud) ]
    |           |
    |           --> [ CI/CD Pipeline (Jenkins / GitHub Actions) ]
    |           --> [ Logging & Tracing (ELK Stack / Zipkin / Sleuth) ]



(7) What is the difference between a monolithic application and a microservices architecture?
################################################################################################
Monolithic Application :
--------------------------
- Single Codebase – All features are tightly coupled in one unit.
- Scalability – Scales as a whole, not component-wise.
- Deployment – One big deployable file (WAR/JAR).
- Fault Isolation – Failure in one part can bring down the entire system.
Microservices Architecture:
------------------------------
- Decoupled Services – Each feature is a separate, independent service.
- Scalability – Can scale services independently as per demand.
- Deployment – Each service deploys separately (independent releases).
- Fault Isolation – Failure in one service doesn’t affect the entire system.


#######################################################
(8) How do microservices communicate with each other?
######################################################
THERE ARE TWO WAYS :-
Synchronous call:
-> we have to wait for one method to execute once method executed and controll comes back to the method the further code will execute. (there is wait priod)
-> it reduce the perfomance of the application.

**Code Behavior**:
-> Method A calls Method B
-> It waits until Method B completes
-> Then it continues with the next line
eg.(a) telephonic call : You can talk to one person at a time. You can't talk to another person until the current call ends.
   (b) Bank Queue: standing in a queue at a bank counter. You wait for the person in front of you to finish before it's your turn.

Asynchronous Call :
-> Tasks can run in parallel. You don’t have to wait for one to finish before starting another.
-> Better performance and responsiveness
-> Requires more careful handling (like callbacks, promises, etc.)
** Code Behavior **:
-> Method A calls Method B
-> Method A doesn’t wait for Method B to finish
-> It continues to execute the next lines immediately
eg. (a) WhatsApp Message: Send a message and continue with your work without waiting for a reply.
    (b) Online Food Order: You place an order and continue watching your show.

(9) In monolithic apps you just need a server and DB, what extra things are required in microservices?
#######################################################################################################
Core Components :
 a. Independent Services→ Each microservice focuses on a single business capability.
 b. Database per Service → Each microservice manages its own data (no direct sharing).
 c. API Communication → Services communicate via REST APIs,, or Messaging (Kafka, RabbitMQ).
 d. Service Discovery → Registry (like Eureka, Consul) so services can find each other.
Infrastructure :
 a. API Gateway → Entry point for requests (e.g., Spring Cloud Gateway, Zuul, Kong).
 b. Configuration Management → Centralized configs (e.g., Spring Cloud Config, Consul).
 c. Load Balancing → Distributes requests across services (Ribbon, Spring Cloud LoadBalancer, Kubernetes Service).
 d. Authentication & Authorization → Secure APIs using OAuth2, JWT, Keycloak, Spring Security.
Deployment :
 a. Docker → Containerize each microservice.
 b. Kubernetes → Orchestrate and manage containers.
 c. CI/CD Pipelines → Automate build, test, and deployment (Jenkins, GitHub Actions, GitLab CI).
Monitoring & Resilience :
 a. Fault Tolerance → Use Hystrix, Resilience4j, Circuit Breaker patterns.
 b. Monitoring → Track health and metrics (Spring Boot Actuator, Micrometer, Prometheus, Grafana).
 c. Logging & Tracing → Centralized logs (ELK Stack, Zipkin, Jaeger).
 d. Health Checks → Each service exposes a health endpoint.


9.1 What is the difference between RestTemplate, Feign Client and WebClient ?
##################################################################################
Feature                         | RestTemplate (with setup)  | WebClient (with setup)  | Feign Client (automatic)
------------------------------- | -------------------------- | ----------------------- | --------------------------
Can use microservice name       | Yes                        | Yes                     | Yes
Requires manual configuration   | Yes (@LoadBalanced)        | Yes (@LoadBalanced)     | No
Built-in load balancing         | Yes                        | Yes                     | Yes
URL hardcoded by default        | Yes                        | Yes                     | No
Effort level                    | Medium                     | Medium                  | Low


Example:
Tool            | Call Example                                                                     
--------------- | --------------------------------------------------------------------------------
RestTemplate    | restTemplate.getForObject("http://MICROSERVICES-1/api/data", String.class);   
  
WebClient       | webClient.get().uri("http://MICROSERVICES-1/api/data").retrieve().bodyToMono(); 

Feign Client    | @FeignClient(name = "MICROSERVICES-1") 
                  public interface Client { 
                  @GetMapping("/api/data") String getData(); 
                  }

(10) Service Discovery (Eureka, Consul) :
##########################################

Q1. What is service discovery in microservices?
👉 It is a mechanism that allows services to register themselves and discover other services dynamically.without hardcoding IPs or URLs.
Note: 
-> Eureka server runs by default on port 8761.
-> If you run eureka server on port 8761. Client (micro services will automatically register with eureka server)

Q2. Why do we need service discovery?
👉 Because service IPs/ports change dynamically (especially in cloud/containers), we cannot hardcode them.

Q3. Example of a service discovery tool?
👉 Eureka, Consul, Kubernetes Service Registry.

Q4. How does Eureka handle service failures?
👉 Eureka checks if services are alive using regular “heartbeat” signals. If a service stops sending these signals, Eureka assumes it’s down and removes it from the list.

Q5. What is Eureka self-preservation mode?
👉 Eureka self-preservation mode prevents removing services too quickly during network problems by keeping the old service information temporarily. This is useful in case Eureka itself temporarily down, so services are not wrongly marked as dead.

Q6. What is the difference between client-side load balancing and server-side load balancing in the context of a service discovery server?
👉 Client-side load balancing → The client itself checks the service registry and picks a service instance to call. (E.g., Eureka Client + Ribbon)
👉 Server-side load balancing → The client just calls a load balancer, and the load balancer decides which service instance to forward the request to. (E.g., Kubernetes)




(11) Config Server (Spring Cloud Config) :
##############################################

Q1. What is the use of a Config Server?
A Config Server centrally manages externalized configurations for all microservices, making it easier to update and maintain settings without redeploying the services.

Q2. Where can Spring Cloud Config store its configuration files?
👉 Spring Cloud Config can store configuration files in Git, on your local filesystem, in a database.

Q3. Why is centralized configuration important?
👉 To avoid duplication, enable dynamic updates.

Q4. How do microservices refresh configuration at runtime?
👉 Using @RefreshScope and Spring Cloud Bus with RabbitMQ/Kafka.

Q5. How would you secure sensitive configs like DB password in Config Server?
👉 By encrypting configs using Spring Cloud Config’s encrypt.key or using Vault for secrets management.

Q6. What problem could occur if Config Server is down? How to solve it?
👉 Services won’t get configs. Solution: enable fail-fast mode with retry or cache configs locally.


(12) API Gateway (Spring Cloud Gateway, Zuul, Kong, Nginx) :
#############################################################

Q1. What is an API Gateway?
👉 A single entry point for all client requests, responsible for routing and filtering.

Q2. Why do we need an API Gateway?
👉 To hide internal service details, enable authentication, load balancing, and monitoring.

Q3. Example of API Gateway tools?
👉 Spring Cloud Gateway, Zuul, Kong, Nginx.

Q4. How does API Gateway handle authentication?
👉 It can validate JWT tokens/ OAuth2 tokens before routing to backend services.

Q5. Can API Gateway handle limiting?
👉 Yes, API Gateway can apply rate limiting to restrict requests per user and prevent system overload.

Q6. Difference between Zuul and Spring Cloud Gateway?
👉 Zuul 1 (blocking) → Each request uses a thread that waits until the response comes back. If many requests come, threads can get stuck, slowing down the system.
👉 Spring Cloud Gateway (non-blocking) → Uses reactive programming; a single thread can handle multiple requests simultaneously without waiting.

Q7. What challenges can arise if API Gateway goes down?
👉 The whole system becomes unavailable. To solve, run multiple gateway instances behind a load balancer.

Q8. What is routing in API Gateway?
👉 Forwarding client requests to the appropriate backend service based on URL, headers, or method.

Q9. What is path rewriting in API Gateway?
👉 Modifying the request path before forwarding to backend.

Q10. What is the difference between routing and path rewriting?
👉 Routing selects the target service; rewriting changes the URL path.

Q11. What are some use cases of path rewriting?
👉 API versioning, redirecting old endpoints, shortening paths.

Q12. Can you give an example of API versioning with path rewriting?
👉 /api/v1/user → rewrite to /user/v1.

Q13. What are predicates in routing?
👉 Conditions that determine which route handles a request (e.g., path, method, header).

Q14. What are filters in routing?
👉 Components that modify requests/responses (e.g., add headers, rewrite path, authentication).

Q15. How do you debug if a route is not working as expected?
👉 Enable Spring Cloud Gateway debug logs, test with Postman/cURL, check predicate conditions, and filter regex.

Q16. What happens if two routes match the same request?
👉 The first matching route in the configuration will be applied.

Q17. How do you handle fallback routes in case a service is down?
👉 Use Spring Cloud Circuit Breaker/Resilience4j with a fallback URI or default response.

Q18. Can you combine load balancing with routing and rewriting?
👉 Yes, by using lb://service-name in the route URI with RewritePath filter.

Q19. What are the performance considerations of path rewriting?
👉 Too many regex-based rewrites and filters can add latency; keep rules optimized.

Q20. Give an example from your project where you used path rewriting.
👉 (Here you should prepare a short real-time example: e.g., migrating /old-api/* to /new-api/* during version upgrade without changing frontend).

Q21. How does the API Gateway decide which microservice should handle a particular request?
-> Client request bhejta hai (e.g. /users/1).
-> Request sabse pehle API Gateway me aati hai.
-> Gateway apni routing rules check karta hai (e.g. /users/** → User Service).
-> Gateway Service Discovery (Eureka/Consul) se check karta hai ki service kaunse IP/Port pe chal rahi hai.
-> Request us microservice instance tak route hoti hai.
-> Microservice apna database access karke response bhejta hai.
-> Gateway response client ko return kar deta hai.



(13) Admin Server (Spring Boot Admin) :
############################################

Q1. What is Spring Boot Admin?
👉 A dashboard to monitor multiple Spring Boot applications using Actuator endpoints.

Q2. What kind of info does it show?
👉 Health, memory, CPU usage, logs, environment, beans.

Q3. How do services connect to Admin Server?
👉 By adding spring-boot-admin-starter-client dependency and pointing to Admin Server URL.

Q4. How does Spring Boot Admin work internally?
👉 Spring Boot Admin connects to your applications and looks at their Actuator endpoints (like health, metrics, logs). It then collects that information and shows it in a simple dashboard so you can monitor all services in one place.

Q5. How do you secure Admin Server in production?
👉 Use Spring Security with basic auth or OAuth2, so only admins can access.

Q6. If Admin Server is down, how will you still monitor services?
👉 Use direct Actuator endpoints, or fallback to Prometheus + Grafana monitoring.


(14). Zipkin Server (Distributed Tracing) :
############################################

Q1. What is Zipkin?
👉 A distributed tracing tool for tracking requests across microservices.

Q2. Why do we need distributed tracing?
👉 In microservices, one request may pass through many services. Distributed tracing helps us follow the journey of that request step by step, so we can easily find where it is slow or failing.

Q3. How do services send trace info to Zipkin?
👉 Using Spring Cloud Sleuth, which adds trace IDs and span IDs in logs and sends them to Zipkin.

Q4. Difference between logging and tracing?
👉 Logging is per service; tracing follows the entire request across multiple services.

Q5. What backends can Zipkin use for storing traces?
👉 In-memory, MySQL, Cassandra, Elasticsearch.

Q6. Have you faced performance issues with tracing?
👉 Yes, because tracing needs to send extra data, it can make the system a bit slower. To fix this, we don’t trace every request — we trace only some (like 10%) so performance is not affected.


(15). Fault Tolerance (Resilience4j, Hystrix, Circuit Breaker) :
###################################################################

Q1. What is fault tolerance?
👉 it is a concept/principle , which define Ability of the system to continue working even if some services fail.

Q2. What is a Circuit Breaker pattern?
👉 It's design pattern, It stops sending requests to a service that is failing for some time, so that the problem does not spread to other services.

Q3. Example of a fault tolerance library?
👉 Resilience4j, Hystrix (now deprecated).

Q4. What is the difference between Retry and Circuit Breaker?
👉 Retry: attempts the request again if it fails.
👉 Circuit Breaker: stops making requests if failures exceed threshold.

Q5. How do you implement fallback in case a service is down?
👉 Using Resilience4j’s @CircuitBreaker annotation with a fallback method to return a default response.

Q6. How do you handle rate limiting in microservices?
👉 With Resilience4j’s rate limiter or at API Gateway level.

Q7. Can you explain a real issue where fault tolerance saved your system?
👉 Example: When our Payment Service went down, Order Service’s circuit breaker returned a fallback (“payment unavailable”) instead of crashing the system.

Q8. What is the difference between Hystrix and Resilience4j?
👉 Hystrix (Netflix) is older and now deprecated. Resilience4j is lightweight, modular, supports Java 8+ functional programming, and integrates well with Spring Boot 2+.

Q9. What is Bulkhead pattern?
👉 The Bulkhead pattern is like dividing a ship into separate compartments. If one part gets damaged, water doesn’t sink the whole ship.
In software, it means separating resources (like threads, memory, or connection pools) for each service/function. This way, if one service fails or gets overloaded, it won’t use up all the resources and stop other services from working.
Example: If Notification Service crashes, it won’t block resources needed by Payment Service — so payments can still work fine.

Q10. What is the Timeout pattern and why is it important?
👉 Timeout makes sure a request to a service doesn’t wait forever. If the service doesn’t respond within X seconds, the call is stopped.
 Real-time example: We set a 2-second timeout for Payment Service calls, so Order Service doesn’t get stuck waiting.

Q11. In terms of fault tolerance, what is the difference between Fail-Fast and Fail-Safe?
👉 Fail-Fast: Stop immediately when a failure happens (e.g., Circuit Breaker).
👉 Fail-Safe: Continue execution by returning a default value or fallback (e.g., Fallback method).

Q12. How do you monitor Circuit Breakers in production?
👉 Using Micrometer + Prometheus + Grafana dashboards, or by exposing metrics via Actuator endpoints.

Q13. What is the Saga Pattern in microservices?
👉 Saga Pattern is a design pattern used in microservices to handle transactions.
Instead of having one big transaction across many services, it breaks it into smaller local transactions.
If one of the steps fails, it uses compensation steps (undo actions) to keep the system consistent.

Q14. What are the two ways to implement Saga?
👉 Choreography (services communicate via events)
👉 Orchestration (a central Saga orchestrator controls the flow).

Q15. Can you give a real example of Saga?
👉 In e-commerce: Order → Payment → Inventory → Shipping. If inventory fails, trigger compensation (refund + cancel order).

Q16. Difference between 2PC (Two-Phase Commit) and Saga?
👉 2PC tries to lock all resources → bad for scalability.
👉 Saga is async, uses compensation instead of locking → better for microservices.

Q17. How does Saga help in fault tolerance?
👉 Even if one service fails, Saga ensures system consistency by rolling back earlier steps.

Q18. Why do we need a Circuit Breaker if we already have Saga?
👉 Saga ensures data consistency across services.
👉 Circuit Breaker prevents cascading failures when a service is down.
👉 Both solve different fault tolerance problems.

Q19. How do you decide between Retry, Circuit Breaker, and Saga?
👉 Retry → when failure is temporary (like network glitch).
👉 Circuit Breaker → when service is unhealthy, stop sending requests.
👉 Saga → when multiple services form a business transaction.

Q20. What tools can you use to implement Saga in Spring Boot?
👉 - Axon Framework, Camunda, Eventuate Tram Saga, or custom using Kafka/RabbitMQ + Choreography.

Q21. Can Saga work with Resilience4j/Hystrix?
👉 Yes, you can use Circuit Breaker + Saga together:
👉 Saga ensures rollback on failure.
👉 Circuit Breaker prevents repeated calls to failing services.







🔧 (4) What is a Service Registry in Microservices?
#####################################################

(5) Steps to Create Eureka Server / Service Registry
###################################################

==============================================================
| Step | Description                                          |
==============================================================
| 1    | Create Eureka Server (Service Registry)              |
--------------------------------------------------------------
|      | a) Create a Spring Boot project                      |
|      | b) Add dependency: 'spring-cloud-starter-netflix-eureka-server' | Dev tool Dependencies
|      | c) Add @EnableEurekaServer in main class             |
|      | d) Configure application.properties:                 |
|         server.port=8761                                    |
|         eureka.client.register-with-eureka=false            |
|         eureka.client.fetch-registry=false  
Note: 
This tells the Eureka Server:
Don't register itself as a client.
Don't try to fetch registry data (because it's the registry).                |
--------------------------------------------------------------
| 2    | Run Eureka Server                                    |
|      | Access: http://localhost:8761                        |
==============================================================



#############################################
🛠️ (6) What is Spring Boot Admin Server?
#############################################

Spring Boot Admin Server is a web-based UI dashboard that lets you monitor and manage Spring Boot applications in real time. 
It provides insight into application health, metrics, environment, thread dumps, and more — all using Spring Boot Actuator endpoints under the hood.

✅ Key Features of Spring Boot Admin:
-> Real-time health status of services
-> Memory, thread, and CPU usage
-> View logs, environment properties, and actuator endpoints
-> Email/Slack notifications for service status
-> UI-based access to /actuator endpoints

📋 How It Works:
-------------------
a. You create a Spring Boot Admin Server (dashboard).
b. Other Spring Boot apps register as Admin Clients.
c. The Admin Server shows their status and health metrics.

📌 Summary:
Use Actuator to make your app observable.
Use Admin Server to see all your services and their health in one place.

#############################
📜 (7) Step-by-Step Instructions:
#############################
1. Set Up Spring Boot Admin Server:
-> Create a Spring Boot Project for the Admin Server.

-> You can use Spring Initializr or your IDE to create a new Spring Boot project.

-> Add Dependencies to your pom.xml:

<dependency>
  <groupId>de.codecentric</groupId>
  <artifactId>spring-boot-admin-starter-server</artifactId>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>

----------------------------------------------------------------------------------
Enable Admin Server by adding @EnableAdminServer annotation to your main class:

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import de.codecentric.boot.admin.server.config.EnableAdminServer;

@SpringBootApplication
@EnableAdminServer
public class AdminServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(AdminServerApplication.class, args);
  }
}
--------------------------------------------------------------------------------
Configure application.properties for Admin Server:

server.port=8080  # Admin Server running on port 8080
spring.boot.admin.ui.title=Spring Boot Admin Server  # Custom title

------------------------------------------------------------------------------

##############################
📡 (8) What is Zipkin Server?
###############################
Zipkin Server is a distributed tracing system that helps you trace and visualize the flow of requests across multiple microservices. 
It shows you how long each service call takes and helps diagnose latency issues or failures in a microservices architecture.

✅ Key Features of Zipkin:
----------------------------
-> Tracks request paths across microservices (traceId)
-> Shows latency and response time of each service
-> Helps identify bottlenecks or failures
-> Integrates with Spring Cloud Sleuth for automatic tracing

(9) Step to Install Zipikin Server:

1. Download Zipkin Servers: https://zipkin.io/pages/quickstart
2. To run jar file : java -jar file-name
3. Access that on port 9411



#############################################
First Microservices App
############################################

1. Create Spring Boot With following dependency

==================================================================================================================
| Dependency Name               | Maven Artifact ID                      | Purpose                             |
==================================================================================================================
| Eureka Discovery Client       | spring-cloud-starter-netflix-eureka-client | Registers service in Eureka     |
| Spring Boot Admin Client     | spring-boot-admin-starter-client       | Sends monitoring data to Admin UI   |
| Spring Web                   | spring-boot-starter-web                | Enables REST API support             |
| DevTools                     | spring-boot-devtools                   | Enables auto-restart and live reload|
| Spring Actuator              | spring-boot-starter-actuator           | Exposes health/metrics endpoints     |
| Zipkin Tracing               | spring-cloud-starter-zipkin            | Sends tracing data to Zipkin         |
| Sleuth (auto tracing)        | spring-cloud-starter-sleuth            | Generates trace & span IDs           |
==================================================================================================================

Step 2: Annotate the Main Class with @EnableDiscoveryClient

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class MyServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyServiceApplication.class, args);
    }
}


Step 3: Configure application.properties file

# Basic Info
spring.application.name=my-service
server.port=8081

# Eureka - Optional if you are running eureka on port 8671
eureka.client.service-url.defaultZone=http://localhost:8761/eureka

# Admin Server
spring.boot.admin.client.url=http://localhost:8080
management.endpoints.web.exposure.include=*

# Zipkin - Optional to mention. It will register with ZIPKIN Automatically
spring.zipkin.base-url=http://localhost:9411
spring.sleuth.sampler.probability=1.0

Very Important Note:
##########################
✅ (10) Tools That Support Service Name Access via Eureka:

Tool	      Can Use Service Name (e.g., MICROSERVICES-1)	       Requires Eureka + Config
Feign Client	         ✅ Yes	                                        Built-in support (just use @FeignClient)
RestTemplate	         ✅ Yes	                                        Requires @LoadBalanced on bean
WebClient	         ✅ Yes	                                        Requires @LoadBalanced on WebClient builder
Browser / Postman	 ❌ No	                                        Needs actual host URL like host.docker.internal

So how to access application with Service name then? To do so, we have to use client like Feign, Webclient, RestTemplate.
Seond These Clients provide load balancer concept. Our microservices will continue to run even when url changes as microservice are being accessed 
using microservice names from eureka server.


(11) Difference Between Rest Template, Webclient & Feign client
##############################################################




####################################################################################
Create Micro service 2 - Use Inter microservices communication --> Use Feign Client
####################################################################################

Step 1: Create Micro Service 2 Spring boot project
Step 2: Add Following Dependencies

==================================================================================================================
| Dependency Name               | Maven Artifact ID                      | Purpose                             |
==================================================================================================================
| Eureka Discovery Client       | spring-cloud-starter-netflix-eureka-client | Registers service in Eureka     |
| Spring Boot Admin Client     | spring-boot-admin-starter-client       | Sends monitoring data to Admin UI   |
| Spring Web                   | spring-boot-starter-web                | Enables REST API support             |
| DevTools                     | spring-boot-devtools                   | Enables auto-restart and live reload|
| Spring Actuator              | spring-boot-starter-actuator           | Exposes health/metrics endpoints     |
| Zipkin Tracing               | spring-cloud-starter-zipkin            | Sends tracing data to Zipkin         |
| Sleuth (auto tracing)        | spring-cloud-starter-sleuth            | Generates trace & span IDs           |
| OpenFeign(Client)            | org.springframework.cloud              | Performs Communication with other microservice|
==================================================================================================================

Step 3: Create Fiegn Interface


import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

@FeignClient(name = "MICROSERVICES-1") 
public interface Client {
	
	@GetMapping("/message")
	public String getData();

}

Step 4: (Optional if you get an error creating Client bean, add the following to Main class )

@SpringBootApplication
@EnableFeignClients(basePackages = "com.microservices3")
public class Microservices2Application {

	public static void main(String[] args) {
		SpringApplication.run(Microservices3Application.class, args);
	}

}

Step 5:

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class SecondController {
	
	@Autowired
	private Client client;
	
	@GetMapping("/fromsecondcontroller")
	public String getMessageFromMicroservices1() {
		return client.getData();
	}

}
Step 6: Add the following to yaml file:
spring:
  application:
    name: microservices-3
  boot:
    admin:
      client:
        url: http://localhost:8080

server:
  port: 8085

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka

management:
  endpoints:
    web:
      exposure:
        include: '*'
  tracing:
    sampling:
      probability: 1.0
  zipkin:
    tracing:
      endpoint: http://localhost:9411/api/v2/spans

Step 7: Test using this url: http://localhost:8085/fromsecondcontroller
#########################################################################################################################



#################################################
Load Balancer Demonstration in microservices
#################################################

In microservice 1 remove port number and start the application on different port using Spring--> run configurations--->arguments---> -Dserver.port=8082 etc

# Basic Info
spring.application.name=my-service
#server.port=8081-------> remove this

# Eureka - Optional if you are running eureka on port 8671
eureka.client.service-url.defaultZone=http://localhost:8761/eureka

# Admin Server
spring.boot.admin.client.url=http://localhost:8080
management.endpoints.web.exposure.include=*

# Zipkin - Optional to mention. It will register with ZIPKIN Automatically
spring.zipkin.base-url=http://localhost:9411
spring.sleuth.sampler.probability=1.0


In Spring Cloud, Feign Client integrates with Ribbon to provide client-side load balancing. Here’s an explanation of how Feign and Ribbon work together. 
This is auto configured. No extra configuration is required


########################
(12) Why API gateway?
##################


(13) How to implement API gateway:
----------------------------

Step 1 create APi gateway Spring boot project with following dependencies
-------------------------------------------------------------------------

		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-gateway</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
Step 2: Mention routing in yaml file
--------------------------------------------
server:
  port: 5555
  
spring:
  application:
    name: API-Gateway

  cloud:
    gateway:
      routes:
        - id: microservice-api-1
          uri: lb://MICROSERVICES-1
          predicates:
            - Path=/micro1/**
          filters:
            - RewritePath=/micro1/(?<segment>.*), /${segment}
        
        - id: microservice-api-3
          uri: lb://MICROSERVICES-3
          predicates:
            - Path=/micro3/**
          filters:
            - RewritePath=/micro3/(?<segment>.*), /${segment}

Step 3: Register with eureka server
-----------------------------------
@SpringBootApplication
@EnableDiscoveryClient
public class ApiGatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(ApiGatewayApplication.class, args);
	}

}

Step 4: Perform testing:
http://localhost:5555/micro3/fromsecondcontroller

################################################################################################

################################################
✅ (14) What is a Spring Cloud Config Server?
################################################

Spring Cloud Config Server is a central configuration management server that allows you to store, manage, and 
serve external configurations for all your microservices from a single location — typically from a Git repository or file system.

🔧 Why is it needed?
------------------------------------
-> In a microservices architecture:
-> Each service may have different configuration (ports, DB URLs, API keys).
-> You may want to change config without redeploying the service.
-> Managing configs across dozens of services becomes a nightmare.

💡 Key Features:
----------------------------------------
Feature				Description
Centralized config	All services fetch config from one place

###########################################
(15) How to secure microservice prject?
##############################################
Step 1: Create AuthService with Spring Security & JWT Token
Step 2: When you login it should generate JWT Token
Step 3: Verify the Token in API Gateway using JwtAuthenticationFilter implements GlobalFilter class
Step 4:  Inside Filter method verify the token




















