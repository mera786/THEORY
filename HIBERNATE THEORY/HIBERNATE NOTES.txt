Basics  :
---------

Q1. What is Hibernate?
Hibernate is an ORM (Object Relational Mapping) framework for Java. It maps Java objects to database tables and handles persistence, so developers can focus on objects rather than writing SQL queries manually.

Q2. What is The Difference Between JDBC and Hibernate ?
  JDBC:
- JDBC is traditional/old Approach to connect and interact with relational databases. where
Developers have to:
   - Write SQL queries manually (INSERT, UPDATE, DELETE, SELECT).
   - Handle ResultSet and map it to Java objects manually.
   - Manage connections, statements, and transactions explicitly.
-	It is database dependent.
-	It doesn‚Äôt support lazy loading.
-	Low performance
-   include a lot of boilerplate code.
 HIBERNATE:
-   Hibernate is a modern approach to connect and interact with relational databases.
-	It is database independent.
-	Hibernate support lazy loading.
-	Hibernate itself manage all transaction.
-	High performance.
-	HIBERNATE SUPPORT CACHING FOR BETTER PERFORMANCE.


Q3. Difference between Hibernate and JPA?
   - JPA is just a specification; it defines interfaces and annotations.
   - Hibernate is a framework that implements JPA and also provides extra features beyond JPA.
   - Example: @Entity, @Id are JPA annotations, while @CreationTimestamp, @UpdateTimestamp are Hibernate-specific.
Note:
üîπ JPA = What to do
üîπ Hibernate = How to do it (plus extra power e.g., caching, criteria queries, better dialect support, lazy loading strategies)

Q4. What is an Entity in JPA/Hibernate?
   - An Entity is a Java class mapped to a database table.
   - Marked with @Entity.
   - Each object = one row, each field = one column.
   - Must have a primary key (@Id).
   - Managed by JPA/Hibernate, so we work with objects instead of SQL.

Q5. What are the core annotations of JPA?
    - @Entity ‚Üí Marks a class as a JPA entity.
    - @Id ‚Üí Primary key identifier.
    - @GeneratedValue ‚Üí Strategy for primary key generation (AUTO, IDENTITY, SEQUENCE, TABLE).
    - @Column ‚Üí Customize column mapping (name, nullable, length, etc.).
    - @Table ‚Üí Map entity to a specific table.
    - @JoinColumn ‚Üí Define foreign key column.
    - @OneToOne, @OneToMany, @ManyToOne, @ManyToMany ‚Üí Define relationships.
    - @Embedded / @Embeddable ‚Üí Embed value types.
    - @Lob ‚Üí Map large objects (CLOB, BLOB).
    - @Transient ‚Üí Exclude field from persistence.
    - @Version ‚Üí Optimistic locking version field.

Q6. Which All Important Interfaces Used in Hibernate ?
SESSIONFACTORY:  SessionFactory is a core interface in Hibernate responsible for:
       -> Connecting to the database
       -> Creating Session objects to perform operations like insert, update, delete, and query

SESSION:     ITS FACTORY FOR TRANSACTION, IT IS USED FOR CONNECTING APPLICATION WITH PERSISTANCE STORE LIKE HIBERNATE FRAMEWORK/DB,  
             IT IS USED TO GET A PYSHICAL CONNECTION WITH DATABASE , IT ALSO PROVIDE METHODS FOR CRUD OPERATIONS
TRANSACTION:  THIS SPECIFY SINGLE UNIT OF WORK.

Q7. Steps to create Sample App of Hibernate ?  
  CREATE POJO CLASS (EMPLOYEE) -> CREATE MAPPING FILE -> CREATE CONFIGURATION FILE -> CREATE CLASS FOR RETERIVING OR STORING POJO -> RUN APPLICATION TO SEE RESULTS.

Q8. What are Hibernate Configuration File ?
 - It is type of file which contains database specific configuration ,
 - It contains database-specific configurations like:
                     - JDBC URL
                     - Username & password
                     - Driver class
                     - Dialect
                     - Mapping resources (entity classes)
 - Hibernate uses this file to initialize the SessionFactory, 
 - and conventionally it name should be hibernate.cfg.xml but you can use any name
 - if you need to connect to sql then this file is important.

Q9. What are Hibernate Mapping file ? 
     A Hibernate Mapping File (.hbm.xml) is an XML file that tells Hibernate how to save Java objects (entities) into database tables and retrieve them. 
     It defines which class maps to which table and how fields connect to columns.

Q10. What is Orm ? 
ORM is a concept to map java objects to database tables and vice versa, 
it take cares of translating java code into required SQL. Popular ORM tool like, hibernate.

Q11. What are the Features of Hibernate ?
- lightweight 
- open source
- ORM BASED
- high performance
- HQL Support
- caching 
- lazy loading
- database independent

Q12. What is Project Lombok ?
Project Lombok is a java library which is used to remove boiler plate code during development like, to generate getter, setters, constructors, to-string by
using some annotations provided by lombok like, @Data, @Setter, @Getter, @NoArgsConstructor, @AllArgsConstructor, @ToString.



Primary Keys & Persistence :
----------------------------

Q1. What are the ID generation strategies in Hibernate?
    - AUTO ‚Üí Hibernate chooses strategy
    - IDENTITY ‚Üí uses auto-increment column in DB
    - SEQUENCE ‚Üí uses database sequence
    - TABLE ‚Üí uses a separate table to generate IDs

Q2. What are the states of an entity in Hibernate?
TRANSIENT: 
->	When object is created using new keyword , it is in transient state.
PERSISTENT STATE:
->	When a transient object is associated with hibernate session by calling the save () or persist() method it enters in the persistent state.
DETACHED STATE:
->	When persistent object is no longer associated with hibernate session because of session closed. It enters in the detached state.
REMOVED STATE:
->	When a persistent object is explicitly marked for the deletion using delete or remove () method it enters in removal state.

Q3. How Will you make Identifier in entity ?
Using @Id with generation type.
If you're using a composite key, use the @EmbeddedId or @IdClass annotations


Q4. How do we define a Composite Primary Key in Hibernate?
Step 1: Create a separate class for the key.
    - Annotate with @Embeddable.
    - Implement Serializable.
    - Add key fields.
    - Override equals() and hashCode().
Step 2: Use this key class in the entity.
    - In the main entity, declare a field of that class.
    - Annotate it with @EmbeddedId.



Relationships :
---------------

Q1. Explain different types of associations in Hibernate ?
        a. OneToOne Mapping - One Record in Table A matches with exactly One Record in Table B
           -> @OneToOne
           For Example:  One Person can have one KYC
        b. OneToMany Mapping - One record in Table A matches with multiple record in Table B
            -> @OneToMany
             Example:  One Post has many Comments / One Hotel can have many reviews  /  One Customer can place many Order
        c. ManyToOne Mapping - Multiple records in Table A matches with one record in Table B
             -> @ManyToOne
        d. ManyToMany Mapping - In Hibernate, a Many-to-Many relationship is used when Each record in Table A can be linked to multiple records in Table B, and                                 vice versa. This requires a join table (association table) in relational databases.
               For example :
                        a. Student ‚Üî Course
                                - One Student ‚Üí Many Courses (One-to-Many).
                                - One Course ‚Üí Many Students (Many-to-One).
                        ‚û°Ô∏è Together, this becomes Many Students ‚Üî Many Courses ‚Üí Many-to-Many.
                         b. One Bus ‚Üî many Stops, one Stop ‚Üî many Buses

Q2. How do you handle bidirectional relationships in JPA?
   - Use mappedBy on the inverse side.
   - Example: In OneToMany, the ManyToOne side is the owning side.
   - Helps avoid infinite recursion and duplicate join columns.

Q3. What is mappedBy?
  - It defines the owner of the relationship.
  - Prevents Hibernate from creating an extra join table/column unnecessarily.

Q4. What is the difference between cascade and fetch in relationships?
     - cascade ‚Üí operations that propagate (e.g., PERSIST, REMOVE)
     - fetch ‚Üí how related entities are loaded (LAZY or EAGER)


Caching & Performance :
-----------------------

Q1. What is Hibernate caching? and what are the Types of Hibernate Caching ?
   - Hibernate Cache is a mechanism in Hibernate ORM to reduce database access by storing frequently used data in memory.
   - Hibernate Cache is In-Memory (Temporary) Storage in RAM.
   - It helps improve performance by:
                      a. Avoiding repetitive SQL queries
                      b. Reducing latency
                      c. Minimizing DB load
   - Types of Hibernate Caching :
                 1. First-Level Cache (Enabled by default)
                    Scope: Per Hibernate Session. In a typical web application, each user request (such as a login) gets its own Hibernate Session
                    Behavior: Same object is never queried twice in a single session
                    Example:
                            Session session = sessionFactory.openSession();
                            User user1 = session.get(User.class, 1L); // hits DB
                            User user2 = session.get(User.class, 1L); // served from cache
                        Note:- This is always enabled and cannot be disabled.
                 2. Second-Level Cache (Optional)
                                 Scope: Across multiple Sessions (shared globally)
                                 Requires configuration
                                 Stores entities between sessions
                                 Uses cache providers like: Ehcache, Caffeine , Redis etc.

Q2. What is lazy loading and eager loading?
üëâ They are fetching strategies in Hibernate/JPA that decide when associated entities should be loaded from the database.
There are types of fetching/loading strategy :
 - Lazy Loading ‚Üí Data fetched only when accessed (default in @OneToMany).
 - Eager Loading ‚Üí Data fetched immediately with parent (default in @ManyToOne).


Transactions & Queries :
------------------------

Q1. What is the role of EntityManager in JPA?
üëâ EntityManager is the main interface in JPA that is used to interact with the database. It manages a persistence context, which means it keeps track of your Java objects (entities) and keeps their state consistent with the database, Think of it like a middleman between your Java code (entities) and the database.
Main responsibilities of EntityManager :
   - CRUD operations (Create, Read, Update, Delete)
   - Running queries (JPQL, Criteria API, Named Queries)
   - Managing transactions (begin, commit, rollback ‚Äì usually with EntityTransaction)
   - Managing persistence context (tracking changes in entities, caching, flushing to DB)

Q2. Difference between JPQL and Criteria API?
    - JPQL ‚Üí Object-oriented query language, similar to SQL but uses entities.
    - Criteria API ‚Üí Type-safe(errors caught at compile time, because you use Java methods/fields), dynamic query building in Java code.

Q3. Difference between HQL and JPQL?
JPQL ‚Üí It is the standard query language from JPA. You write queries using entity names and their fields, not database tables and columns. It works with any           JPA provider.
HQL ‚Üí  It works almost the same, but also has extra features, like using database-specific functions or some Hibernate-only keywords.
Example : In Spring Boot repositories 
| Type                        | Do you write query? | Uses JPQL/HQL?                   | Example                                               |
| --------------------------- | ------------------- | -------------------------------- | ----------------------------------------------------- |
| **Derived / Finder method** | No                  | JPQL internally (auto-generated) | `findByEmail(String email)`                           |
| **@Query with JPQL**        | Yes                 | JPQL                             | `@Query("SELECT u FROM User u WHERE u.email = :email")|
| **@Query with native SQL**  | Yes                 | SQL                              | `@Query(value="SELECT * FROM users WHERE email=:email",                                                                                                                                            nativeQuery=true)` |

Q4. How to handle optimistic vs pessimistic locking in Hibernate?












    ###########################
(5)   Normalization
    ############################

1. 1NF (First Normal Form)
-> Should have atomic values
-> Identify each record uniquely
-> No repeating groups

2. 2NF (Second Normal Form)
-> Group the columns based on entity & seperate that to different tables

3. 3 NF (Third Normal Form)]
-> Remove all duplicate/redundant values
-> Ensure each record is uniquely identified by a Primary Key
-> Create relations between tables using Foreign Keys


(15) DIFERENCE BETWEEN CURRENTSESSION AND OPENSESSION?

| Feature                    | `getCurrentSession()`                              | `openSession()`                                               |
| -------------------------- | -------------------------------------------------- | ------------------------------------------------------------- |
| **Session Scope**          | Bound to the **current transaction** or **thread** | Not bound to transaction; it's **manual** and **independent** |
| **Session Closing**        | Automatically closed when transaction ends         | Needs to be **explicitly closed** by the developer            |
| **Recommended For**        | Use with **transaction management** (e.g. Spring)  | Use when managing session manually                            |
| **Session Sharing**        | Reuses the same session in the same thread         | Always opens a **new session** each time                      |
| **Performance**            | Better suited for standard request-response models | Less efficient if misused (more overhead)                     |
| **Requires Configuration** | Yes (`hibernate.current_session_context_class`)    | No special configuration needed                               |

(16) DIFFERENCE BETWEEN SESSION LOAD() AND GET() METHOD?

| Feature                 | `get()`                                       | `load()`                                        |
| ----------------------- | --------------------------------------------- | ----------------------------------------------- |
| **Return Type**         | Returns the actual object                     | Returns a **proxy** (fake object at first)      |
| **When Data Not Found** | Returns `null` if object not found            | Throws **ObjectNotFoundException** if not found |
| **When Query Runs**     | Query runs **immediately**                    | Query runs **when you access object fields**    |
| **Use Case**            | Use when you're not sure if the object exists | Use when you're sure the object exists          |
| **Performance**         | Slightly slower (fetches immediately)         | Slightly better (lazy loading with proxy)       |




(17) DIFFERENCE BETWEEN SAVE & PERSIST METHOD?

| Feature                 | `save()` Method                                        | `persist()` Method                              |
| ----------------------- | ------------------------------------------------------ | ----------------------------------------------- |
| **Belongs to**          | Hibernate-specific (native method)                     | JPA standard method (recommended for JPA usage) |
| **Return type**         | ‚úÖ Returns the **generated ID** (Serializable)         | ‚ùå Returns **nothing (void)**                   |
| **When can we use it?** | Even **outside a transaction**, it still works         | Must be called **within a transaction**         |
| **Adds object to...**   | Adds it to **persistence context + returns ID**        | Adds it to **persistence context only**         |
| **Duplicates allowed?** | Yes, can cause **duplicates** if object already has ID | Throws **Exception** if object has assigned ID  |
| **Flush timing**        | Can flush immediately                                  | Flushes only when transaction commits           |
| **Used with**           | Only in **Hibernate**                                  | Can be used with **JPA or Hibernate**           |

(18) DIFFERENCE BETWEEN SESSION AND SESSIONFACTORY?

| Feature             | `SessionFactory`                                 | `Session`                                           |
| ------------------- | ------------------------------------------------ | --------------------------------------------------- |
| **What is it?**     | A factory (creator) that makes `Session` objects | A single session used to interact with the database |
| **Creation**        | Created **only once** for the whole application  | Created **every time** we need to work with DB      |
| **Heavy or Light?** | ‚úÖ Heavy object (expensive to create)            | ‚úÖ Lightweight object (cheap to create)             |
| **Thread Safe?**    | ‚úÖ Yes ‚Äî can be shared across threads            | ‚ùå No ‚Äî use only in one thread at a time            |
| **Used For**        | Creating `Session`, managing DB config           | CRUD operations: save, update, delete, query        |
| **Lifecycle**       | Exists until the application stops               | Exists only during one DB conversation/transaction  |
| **Analogy**         | Like a **Car Factory**                           | Like the **Car** made by the factory                |


(20) WHAT IS DIALECT IN HIBERNATE?
Dialect is a concept related to configuration of database where It tells Hibernate how to generate appropriate SQL statements for the specific database.

(21) WHAT HAPPENS IF DIALECT IS MISSING?
Hibernate Tries to Guess the Dialect but this is not recommended if Failure to Guess Dialect it will throw a HibernateException with related message.



(23) How will you join two tables in Hibernate?
You can join two tables in Hibernate using two main approaches:
(a)  Through Entity Mappings using Annotations :
-> @OneToOne
-> @OneToMany
-> @ManyToOne
->@ManyToMany
Note:-Use @JoinColumn to specify the foreign key column.

(b) Using HQL (Hibernate Query Language) or JPQL :
ex- @Query("SELECT e FROM Employee e JOIN e.address a WHERE a.city = :city")
List<Employee> findEmployeesByCity(@Param("city") String city);



(27) HOW CAN YOU DETACH AN OBJECT IN HIBERNATE?
Detaching an object refers to removing its association with current hibernate session so there are several ways to detach using session interface‚Äôs method:
-	Evict()
-	Clear()
-	Detach()
-	Close()

(28) WHAT IS TRANSACTION?

A transaction is a group of operations performed as a single unit to ensure data integrity in the database.
Hibernate provides the Transaction interface to manage database transactions.
| **Property**        | **Meaning**                                                             |
| ------------------- | ----------------------------------------------------------------------- |
| **A ‚Äì Atomicity**   | All steps succeed or all fail ‚Äî no partial change.                      |
| **C ‚Äì Consistency** | Keeps the database in a valid, expected state before & after execution. |
| **I ‚Äì Isolation**   | Each transaction is separate; no mixing of data between them.           |
| **D ‚Äì Durability**  | Once saved (committed), the change stays even after power failure.      |

** Transaction Handling in Hibernate vs JPA vs Spring Boot **

| **Aspect**              | **Hibernate**                          | **JPA**                          | **Spring Boot (Spring)**                    |
| ----------------------- | -------------------------------------- | -------------------------------- | ------------------------------------------- |
| **Transaction API**     | `Transaction`                          | `EntityTransaction`              | `@Transactional` annotation                 |
| **Abstraction Level**   | Hibernate-specific                     | JPA specification-level          | Framework-level abstraction                 |
| **Declarative Support** | ‚ùå Not built-in                         | ‚ùå Not built-in                   | ‚úÖ Yes, using annotations (`@Transactional`) |
| **Manual Handling**     | Required (`tx.begin()`, `tx.commit()`) | Required (`begin()`, `commit()`) | Optional (can be auto-managed)              |
| **Ease of Use**         | Medium                                 | Medium                           | ‚úÖ Very easy with annotations                |
| **Example**             | `session.beginTransaction()`           | `entityManager.getTransaction()` | `@Transactional` on method/class            |

     ############################
(29) What is Spring Data JPA?
     ############################

a. Spring Data JPA makes working with JPA easier by eliminating boilerplate code required for common database operations like saving, updating, deleting, and finding entities.

d. By default, Spring Data JPA uses Hibernate as the ORM (Object Relational Mapping) tool in Spring Boot applications (unless you configure another JPA provider manually).


##############################################################
(32) DIFFERENCE BETWEEN JPQL AND DERIVED QUERY/ finder method
##############################################################


| Feature             | JPQL (Java Persistence Query Language)                                                                        | Derived Query (Method Name Query)                                                                           |
| ------------------- | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **Definition**      | JPQL is a query language similar to SQL but works with **entity objects** instead of database tables.         | Derived Queries are methods in Spring Data JPA repositories whose **names define the query automatically**. |
| **Query Writing**   | Written explicitly using `@Query` annotation or `EntityManager.createQuery()`.                                | Written by defining **method names** in repository interface following Spring conventions.                  |
| **Complexity**      | Can handle **complex queries** including joins, aggregation, subqueries, and functions.                       | Best for **simple queries** (like findBy, countBy, existsBy). Complex queries may become unreadable.        |
| **Annotation**      | Often requires `@Query` annotation (optional if using EntityManager).                                         | No annotation needed; method name itself defines the query.                                                 |
| **Example**         | `java @Query("SELECT u FROM User u WHERE u.email = :email") User findByEmail(@Param("email") String email); ` | `java User findByEmail(String email); `                                                                     |
| **Flexibility**     | High flexibility; you can write any JPQL statement.                                                           | Limited flexibility; constrained by method naming conventions.                                              |
| **Readability**     | Medium; query is written as a string (can be long).                                                           | High for simple queries; very readable if method names are simple.                                          |
| **Maintainability** | Easier to modify complex queries, as you can directly edit JPQL.                                              | Harder for complex queries because long method names become cumbersome.                                     |
| **Return Types**    | Can return single entity, list, DTO projection, or scalar values.                                             | Can return entity, list, count, boolean, or optional types.                                                 |

##########################################
 (33) What is Criteria API in Hibernate ?
##########################################
The Criteria API in Hibernate (and JPA) is a programmatic way to build database queries instead of writing raw HQL/JPQL.


#############################################
(34) How Hibernate manages transactions ?
###############################################

In short, Hibernate manages transactions through JDBC connections (or JTA in enterprise apps) and its own Transaction API.

Here‚Äôs the flow:
- Open Session ‚Üí Hibernate gets a database connection.
- Begin Transaction ‚Üí session.beginTransaction() tells Hibernate to disable auto-commit and start a DB transaction.
- Perform Operations ‚Üí Hibernate executes SQL (INSERT/UPDATE/DELETE/SELECT) but delays actual commit.
- Commit / Rollback : 
     tx.commit() ‚Üí flushes changes to DB and commits the transaction.
     tx.rollback() ‚Üí undoes all pending operations.
- Close Session ‚Üí Hibernate releases the connection back to the pool.














