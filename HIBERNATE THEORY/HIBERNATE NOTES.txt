Basics  :
---------

Q1. What is Hibernate?
Hibernate is an ORM (Object Relational Mapping) framework for Java. It maps Java objects to database tables and handles persistence, so developers can focus on objects rather than writing SQL queries manually.

Q2. What is The Difference Between JDBC and Hibernate ?
  JDBC:
- JDBC is traditional/old Approach to connect and interact with relational databases. where
Developers have to:
   - Write SQL queries manually (INSERT, UPDATE, DELETE, SELECT).
   - Handle ResultSet and map it to Java objects manually.
   - Manage connections, statements, and transactions explicitly.
-	It is database dependent.
-	It doesn’t support lazy loading.
-	Low performance
-   include a lot of boilerplate code.
 HIBERNATE:
-   Hibernate is a modern approach to connect and interact with relational databases.
-	It is database independent.
-	Hibernate support lazy loading.
-	Hibernate itself manage all transaction.
-	High performance.
-	HIBERNATE SUPPORT CACHING FOR BETTER PERFORMANCE.


Q3. Difference between Hibernate and JPA?
   - JPA is just a specification; it defines interfaces and annotations.
   - Hibernate is a framework that implements JPA and also provides extra features beyond JPA.
   - Example: @Entity, @Id are JPA annotations, while @CreationTimestamp, @UpdateTimestamp are Hibernate-specific.
Note:
🔹 JPA = What to do
🔹 Hibernate = How to do it (plus extra power e.g., caching, criteria queries, better dialect support, lazy loading strategies)

Q4. What is an Entity in JPA/Hibernate?
   - An Entity is a Java class mapped to a database table.
   - Marked with @Entity.
   - Each object = one row, each field = one column.
   - Must have a primary key (@Id).
   - Managed by JPA/Hibernate, so we work with objects instead of SQL.

Q5. What are the core annotations of JPA?
    - @Entity → Marks a class as a JPA entity.
    - @Id → Primary key identifier.
    - @GeneratedValue → Strategy for primary key generation (AUTO, IDENTITY, SEQUENCE, TABLE).
    - @Column → Customize column mapping (name, nullable, length, etc.).
    - @Table → Map entity to a specific table.
    - @JoinColumn → Define foreign key column.
    - @OneToOne, @OneToMany, @ManyToOne, @ManyToMany → Define relationships.
    - @Embedded / @Embeddable → Embed value types.
    - @Lob → Map large objects (CLOB, BLOB).
    - @Transient → Exclude field from persistence.
    - @Version → Optimistic locking version field.

Q6. Which All Important Interfaces Used in Hibernate ?
SESSIONFACTORY:  SessionFactory is a core interface in Hibernate responsible for:
       -> Connecting to the database
       -> Creating Session objects to perform operations like insert, update, delete, and query

SESSION:     ITS FACTORY FOR TRANSACTION, IT IS USED FOR CONNECTING APPLICATION WITH PERSISTANCE STORE LIKE HIBERNATE FRAMEWORK/DB,  
             IT IS USED TO GET A PYSHICAL CONNECTION WITH DATABASE , IT ALSO PROVIDE METHODS FOR CRUD OPERATIONS
TRANSACTION:  THIS SPECIFY SINGLE UNIT OF WORK.

Q7. Steps to create Sample App of Hibernate ?  
  CREATE POJO CLASS (EMPLOYEE) -> CREATE MAPPING FILE -> CREATE CONFIGURATION FILE -> CREATE CLASS FOR RETERIVING OR STORING POJO -> RUN APPLICATION TO SEE RESULTS.

Q8. What are Hibernate Configuration File ?
 - It is type of file which contains database specific configuration ,
 - It contains database-specific configurations like:
                     - JDBC URL
                     - Username & password
                     - Driver class
                     - Dialect
                     - Mapping resources (entity classes)
 - Hibernate uses this file to initialize the SessionFactory, 
 - and conventionally it name should be hibernate.cfg.xml but you can use any name
 - if you need to connect to sql then this file is important.

Q9. What are Hibernate Mapping file ? 
     A Hibernate Mapping File (.hbm.xml) is an XML file that tells Hibernate how to save Java objects (entities) into database tables and retrieve them. 
     It defines which class maps to which table and how fields connect to columns.

Q10. What is Orm ? 
ORM is a concept to map java objects to database tables and vice versa, 
it take cares of translating java code into required SQL. Popular ORM tool like, hibernate.

Q11. What are the Features of Hibernate ?
- lightweight 
- open source
- ORM BASED
- high performance
- HQL Support
- caching 
- lazy loading
- database independent

Q12. What is Project Lombok ?
Project Lombok is a java library which is used to remove boiler plate code during development like, to generate getter, setters, constructors, to-string by
using some annotations provided by lombok like, @Data, @Setter, @Getter, @NoArgsConstructor, @AllArgsConstructor, @ToString.


Q13. What is Normalization?
Normalization is a database design technique that organizes tables to reduce redundancy and avoid data problems (or inconsistencies). It is done in different stages called Normal Forms. Each normal form defines a set of rules. The most commonly used are 1NF, 2NF, and 3NF.
👉 1. 1NF (First Normal Form)
-> Should have atomic values
-> Identify each record uniquely
-> No repeating groups

👉 2. 2NF (Second Normal Form)
-> Group the columns based on entity & seperate that to different tables

👉 3. 3NF (Third Normal Form)]
-> Remove all duplicate/redundant values
-> Ensure each record is uniquely identified by a Primary Key
-> Create relations between tables using Foreign Keys





Primary Keys & Persistence :
----------------------------

Q1. What are the ID generation strategies in Hibernate?
    - AUTO → Hibernate chooses strategy
    - IDENTITY → uses auto-increment column in DB
    - SEQUENCE → uses database sequence
    - TABLE → uses a separate table to generate IDs

Q2. What are the states of an entity in Hibernate?
TRANSIENT: 
->	When object is created using new keyword , it is in transient state.
PERSISTENT STATE:
->	When a transient object is associated with hibernate session by calling the save () or persist() method it enters in the persistent state.
DETACHED STATE:
->	When persistent object is no longer associated with hibernate session because of session closed. It enters in the detached state.
REMOVED STATE:
->	When a persistent object is explicitly marked for the deletion using delete or remove () method it enters in removal state.

Q3. How Will you make Identifier in entity ?
Using @Id with generation type.
If you're using a composite key, use the @EmbeddedId or @IdClass annotations


Q4. How do we define a Composite Primary Key in Hibernate?
Step 1: Create a separate class for the key.
    - Annotate with @Embeddable.
    - Implement Serializable.
    - Add key fields.
    - Override equals() and hashCode().
Step 2: Use this key class in the entity.
    - In the main entity, declare a field of that class.
    - Annotate it with @EmbeddedId.


Q5. What are the difference between get and load method ?
| Feature                 | `get()`                                       | `load()`                                        |
| ----------------------- | --------------------------------------------- | ----------------------------------------------- |
| **Return Type**         | Returns the actual object                     | Returns a **proxy** (fake object at first)      |
| **When Data Not Found** | Returns `null` if object not found            | Throws **ObjectNotFoundException** if not found |
| **When Query Runs**     | Query runs **immediately**                    | Query runs **when you access object fields**    |
| **Use Case**            | Use when you're not sure if the object exists | Use when you're sure the object exists          |
| **Performance**         | Slightly slower (fetches immediately)         | Slightly better (lazy loading with proxy)       |

Q6. Difference between save() & persist() method?
👉 save() is Hibernate-specific and returns the generated ID, while persist() is JPA standard, returns nothing, and needs an active transaction.

Q7. How can you detach an object in Hibernate?
Detaching an object refers to removing its association with current hibernate session so there are several ways to detach using session interface’s method:
-	Evict()
-	Clear()
-	Detach()
-	Close()

Q8. IF I WANT SOME FIELD TO STORE INTO DATABASE AS ENCRYPTED FORM HOW WILL BE DONE?
You can encrypt a field before saving it and decrypt it when reading. In Hibernate/JPA, this can be done using @Convert with AttributeConverter interface 
which has to incomplete method like, convertToDatabaseColumn(X attribute) , convertToEntityAttribute(Y dbData).


Q9. What is the difference between merge() and update()?
update() → Reattaches a detached entity to the session; throws error if another instance with same ID is already in session.
merge() → Copies values from a detached entity into a managed one; safe to use even if another instance with same ID exists in session.
👉 In short: use merge() when unsure, it’s safer than update()
Note :- 
detached entity?
 - An entity becomes detached when it was once managed by Hibernate (inside a Session / Persistence Context) but is now out of it.
 - Example: After you close the session or commit the transaction, the entity is no longer tracked → that’s a detached entity.
            Session session1 = sessionFactory.openSession();
            User user = session1.get(User.class, 1L);  // managed
            session1.close();                          // now detached
reattached mean?
- Hibernate needs the entity to be managed again (inside a new session) so it can track changes and sync them with the database.
- When you call update(), Hibernate tries to reattach the detached entity to the new session.
- When you call merge(), Hibernate creates/uses a managed copy in the new session instead of directly reattaching.





Relationships :
---------------

Q1. Explain different types of associations in Hibernate ?
        a. OneToOne Mapping - One Record in Table A matches with exactly One Record in Table B
           -> @OneToOne
           For Example:  One Person can have one KYC
        b. OneToMany Mapping - One record in Table A matches with multiple record in Table B
            -> @OneToMany
             Example:  One Post has many Comments / One Hotel can have many reviews  /  One Customer can place many Order
        c. ManyToOne Mapping - Multiple records in Table A matches with one record in Table B
             -> @ManyToOne
        d. ManyToMany Mapping - In Hibernate, a Many-to-Many relationship is used when Each record in Table A can be linked to multiple records in Table B, and                                 vice versa. This requires a join table (association table) in relational databases.
               For example :
                        a. Student ↔ Course
                                - One Student → Many Courses (One-to-Many).
                                - One Course → Many Students (Many-to-One).
                        ➡️ Together, this becomes Many Students ↔ Many Courses → Many-to-Many.
                         b. One Bus ↔ many Stops, one Stop ↔ many Buses

Q2. How do you handle bidirectional relationships in JPA?
   - Use mappedBy on the inverse side.
   - Example: In OneToMany, the ManyToOne side is the owning side.
   - Helps avoid infinite recursion and duplicate join columns.

Q3. What is mappedBy?
  - It defines the owner of the relationship.
  - Prevents Hibernate from creating an extra join table/column unnecessarily.

Q4. What is the difference between cascade and fetch in relationships?
     - cascade → operations that propagate (e.g., PERSIST, REMOVE)
     - fetch → how related entities are loaded (LAZY or EAGER)

Q5. How will you join two tables in Hibernate?
You can join two tables in Hibernate using two main approaches:
(a)  Through Entity Mappings using Annotations :
-> @OneToOne
-> @OneToMany
-> @ManyToOne
->@ManyToMany
Note:-Use @JoinColumn to specify the foreign key column.

(b) Using HQL (Hibernate Query Language) or JPQL :
ex- @Query("SELECT e FROM Employee e JOIN e.address a WHERE a.city = :city")
List<Employee> findEmployeesByCity(@Param("city") String city);



Caching & Performance :
-----------------------

Q1. What is Hibernate caching? and what are the Types of Hibernate Caching ?
   - Hibernate Cache is a mechanism in Hibernate ORM to reduce database access by storing frequently used data in memory.
   - Hibernate Cache is In-Memory (Temporary) Storage in RAM.
   - It helps improve performance by:
                      a. Avoiding repetitive SQL queries
                      b. Reducing latency
                      c. Minimizing DB load
   - Types of Hibernate Caching :
                 1. First-Level Cache (Enabled by default)
                    Scope: Per Hibernate Session. In a typical web application, each user request (such as a login) gets its own Hibernate Session
                    Behavior: Same object is never queried twice in a single session
                    Example:
                            Session session = sessionFactory.openSession();
                            User user1 = session.get(User.class, 1L); // hits DB
                            User user2 = session.get(User.class, 1L); // served from cache
                        Note:- This is always enabled and cannot be disabled.
                 2. Second-Level Cache (Optional)
                                 Scope: Across multiple Sessions (shared globally)
                                 Requires configuration
                                 Stores entities between sessions
                                 Uses cache providers like: Ehcache, Caffeine , Redis etc.

Q2. What is lazy loading and eager loading?
👉 They are fetching strategies in Hibernate/JPA that decide when associated entities should be loaded from the database.
There are types of fetching/loading strategy :
 - Lazy Loading → Data fetched only when accessed (default in @OneToMany).
 - Eager Loading → Data fetched immediately with parent (default in @ManyToOne).


Transactions & Queries :
------------------------

Q1. What is the role of EntityManager in JPA?
👉 EntityManager is the main interface in JPA that is used to interact with the database. It manages a persistence context, which means it keeps track of your Java objects (entities) and keeps their state consistent with the database, Think of it like a middleman between your Java code (entities) and the database.
Main responsibilities of EntityManager :
   - CRUD operations (Create, Read, Update, Delete)
   - Running queries (JPQL, Criteria API, Named Queries)
   - Managing transactions (begin, commit, rollback – usually with EntityTransaction)
   - Managing persistence context (tracking changes in entities, caching, flushing to DB)

Q2. Difference between JPQL and Criteria API?
    - JPQL → Object-oriented query language, similar to SQL but uses entities.
    - Criteria API → Type-safe(errors caught at compile time, because you use Java methods/fields), dynamic query building in Java code.

Q3. Difference between HQL and JPQL?
JPQL → It is the standard query language from JPA. You write queries using entity names and their fields, not database tables and columns. It works with any           JPA provider.
HQL →  It works almost the same, but also has extra features, like using database-specific functions or some Hibernate-only keywords.
Example : In Spring Boot repositories 
| Type                        | Do you write query? | Uses JPQL/HQL?                   | Example                                               |
| --------------------------- | ------------------- | -------------------------------- | ----------------------------------------------------- |
| **Derived / Finder method** | No                  | JPQL internally (auto-generated) | `findByEmail(String email)`                           |
| **@Query with JPQL**        | Yes                 | JPQL                             | `@Query("SELECT u FROM User u WHERE u.email = :email")|
| **@Query with native SQL**  | Yes                 | SQL                              | `@Query(value="SELECT * FROM users WHERE email=:email",                                                                                                                                            nativeQuery=true)` |

Q4. Explain Difference between OpenSession and CurrentSession ?
👉 openSession() → Always creates a new Session, you must close it manually.
👉 getCurrentSession() → Returns a Session bound to the current context/transaction, and it closes automatically.

Q5. Difference between Session and SessionFactory?
👉 SessionFactory → A heavyweight object created once, used to make Sessions.
👉 Session → A lightweight object created from SessionFactory to interact with the database (CRUD).

Q6. What is Dialect in Hibernate?
Dialect is a concept related to configuration of database where It tells Hibernate how to generate appropriate SQL statements for the specific database.

Q7. What happens if Dialect is missing?
Hibernate Tries to Guess the Dialect but this is not recommended if Failure to Guess Dialect it will throw a HibernateException with related message.

Q8. What is Transaction?
A transaction is a group of operations performed as a single unit to ensure data integrity in the database.
there are 4 properties (ACID) of a transactions :
| **Property**        | **Meaning**                                                             |
| ------------------- | ----------------------------------------------------------------------- |
| **A – Atomicity**   | All steps succeed or all fail — no partial change.                      |
| **C – Consistency** | Keeps the database in a valid, expected state before & after execution. |
| **I – Isolation**   | Each transaction is separate; no mixing of data between them.           |
| **D – Durability**  | Once saved (committed), the change stays even after power failure.      |


Q9. What is Spring Data JPA?
  - Spring Data JPA makes working with JPA easier by eliminating boilerplate code required for common database operations like saving, updating, deleting, and      finding entities.
  - By default, Spring Data JPA uses Hibernate as the ORM (Object Relational Mapping) tool in Spring Boot applications (unless you configure another JPA            provider manually).

Q10. How Hibernate manages transactions?
Here are some steps  :
      - Open a Session — Session session = sessionFactory.openSession();
      - Begin a Transaction — Transaction tx = session.beginTransaction();
      - Perform DB operations — session.save()/update()/delete()/query. 
      - Commit — tx.commit();
      - Close Session — session.close();
      - Rollback on error  : When using Spring’s @Transactional, rollback on unchecked exceptions is automatic by default
Note:- Declarative vs programmatic :-  a. programmatic uses session.beginTransaction()/commit(); 
                                       b. declarative (recommended in apps) uses @Transactional (Spring/JTA) where the framework manages begin/commit/rollback                                             and propagation.


Q11. How do you integrate Spring Boot with Hibernate/JPA?
  - Use spring-boot-starter-data-jpa.
  - Configure application.properties with DB details.
  - Create entities, repositories (JpaRepository), and Spring Boot auto-configures EntityManager.

Q12. How to handle optimistic vs pessimistic locking in Hibernate?
Optimistic Locking :
       - Idea → Multiple users can read the same data, but only one can update it successfully. Others fail if data has changed in the meantime.
       - How → Uses a @Version column (usually int or long) in the entity.
       - If two users update the same row, Hibernate checks the @Version. If it changed, one update fails with OptimisticLockException.
- Example in Spring Boot: 
@Entity
public class Product {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    private int stock;

    @Version   // Hibernate manages this column automatically
    private int version;
}

@Service
public class ProductService {
    
    @Autowired
    private ProductRepository repo;

    @Transactional
    public void updateStock(Long productId, int newStock) {
        Product product = repo.findById(productId).orElseThrow();
        product.setStock(newStock);  // Hibernate will check @Version when committing
    }
}
Pessimistic Locking :
       - Idea → “Lock the row in the database so no one else can modify it until I’m done.”
       - How → Uses database-level locks (SELECT ... FOR UPDATE).
       - Hibernate → Use @Lock in repository methods or entityManager.lock(...).
- Example in Spring Boot:
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)  // DB row is locked until transaction ends
    @Query("select p from Product p where p.id = :id")
    Product findProductForUpdate(@Param("id") Long id);
}

@Service
public class ProductService {
    
    @Autowired
    private ProductRepository repo;

    @Transactional
    public void updateStockWithLock(Long productId, int newStock) {
        Product product = repo.findProductForUpdate(productId);
        product.setStock(newStock);  // Row is locked until commit
    }
}














